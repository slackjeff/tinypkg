#!/bin/sh
################################################################
# AUTOR   : Jefferson 'Slackjeff' Carneiro
# EMAIL   : jeffersoncarneiro AT slackjeff dot com dot br
# Tinypkg : Create, install, remove package.
# VERSION : 1.1.2
#
#VERY IMPORTANT note!
# keep this program < 250 lines of code! And also maintain
# the POSIX Shell.
################################################################

#=========================== VARS
# Format package.
export RED="\033[91;1m"
export RESET="\033[0m"
export BLUE="\033[94;1m"
export YELLOW="\033[92;1m"

export pkgFormat='spkg'

# Support UNICODE off.
export LC_ALL='C'; export LANG='C'

#=========================== FUNCTIONS
# An alternative to the real basename.
basename() {
    printf '%s\n' "${1##*/}"
}

# An alternative to the real dirname.
dirname() {
    printf '%s\n' "${1%/*}"
}

printError() {
    printf '%b' "${RED}[ERROR]${RESET} "
    printf '%b\n' "$@"
    exit 1
}

printInfo() {
    printf '%b' "${BLUE}[INFO]${RESET} "
    printf '%b\n' "$@"
}

printWar() {
    printf '%b' "${YELLOW}[WAR]${RESET} "
    printf '%b\n' "$@"
}

NULL() {
    [ -z "$1" ] && printInfo "Name of package... SOFTWARE-VERSION.${pkgFormat}"
    exit 1
}

# Check package extension and blabla.
CHECKEXT() {
    # Created with tinypkg?
    [ "$(printf '%s\n' ${1##*.})" != "$pkgFormat" ] && printError "$1 Not created with tinypkg."
    # name of package have space?
    case "$1" in *' '*) printError "Please, don't use spaces." ;; esac
}

# Make package
CREATEPKG() {
    CHECKEXT "$(basename $1)" # Check's of name package
    target="$(dirname $(pwd))"  # don't use ../ anymore.
    # creating the package a directory above.
    if tar -cf "${target}/$1" .; then
        printInfo "${target}/$1 The package was created successfully."
    else
        printError "Error!"
    fi
    ( # Create hash and exit subshell.
        cd ..
        [ ! -e "$1" ] && { printError "Package does not exist, hash cannot be created."; exit 1 ;}
        if sha256sum "${1}" > "${1}.sha256sum"; then
            printInfo "${1}.sha256sum was created"; return 0
        else
            printError "$1.sha256sum not created!"
        fi
    )
}

# Install package
INSTALL() {
    # List of tracks
    export dbtinypkg="${FAKE}/var/db/tinypkg"
    [ ! -d "${dbtinypkg}" ] && mkdir -p "$dbtinypkg" # Exist db dir of tracks?

    CHECKEXT "$(basename $1)" # Check's of name package

    # VERIFY EXTENSION HERE

    printInfo "INSTALL PACKAGE: ${1}"
    # Install package
    tar xvf "$1" -C "${FAKE}/" >> "${dbtinypkg}/$(basename "$1")" || printError "ERROR pkg $1 has not been installed."
    # clean tracking
    sed -i 's/^\.//g; /^\/$/d' "${dbtinypkg}/$(basename "$1")" || printError "Error when clearing package track!"

    # Need these variables to move the track correctly.
    pkg4strip="$1"; stripext="${pkg4strip%.$pkgFormat}"; stripext="$(basename "$stripext")"

    # Remove .extension of package, only pkg-version keep.
    mv "${dbtinypkg}/$(basename "$1")" "${dbtinypkg}/$stripext" || printError "Error with the track."

    # Ok ok
    printf '%s\n' "DIR OF INSTALED: ${YELLOW}${FAKE}${RESET}/"
    printf '%s\n' "TRACK: ${YELLOW}${dbtinypkg}/$(basename "$stripext")${RESET}"
    printf '%s\n' "${RED}-------${RESET} ${BLUE}Installation complete${RESET}"
    return 0
}

# Remove package
REMOVE() {
  # checking if there is more than one package with the same initials name
  # Example: youtube-dl, youtube-upload. blablabla
  # If it exists, we increment and just show pattern it to user.
  mpkg=0 #more package
  npkg=0 # no package found
  cd "$dbtinypkg" # for dont use 'more and more' basename.
  for list in *; do
    if echo "$list" | grep -w -E "^$1" 1>/dev/null 2>/dev/null; then
      printWar "[FOUND] $list"
      pkgtrack="$list"
      mpkg="$((mpkg + 1))" # Inc
     else
      npkg="$((npkg + 1))"
    fi
  done
  # If there is more than one pattern, print and exit.
  if [ "$mpkg" -gt '1' ]; then
    printWar "$mpkg occurrences found with '$1'. Use full name to remove!"
    exit 1
  elif [ "$npkg" -gt '0' ] && [ "$mpkg" -lt '1' ]; then
    printWar "No matches for $1"
    exit 0
  fi

  # Okay, if we find only one pattern, it's time to remove it.
  while IFS= read -r tfile; do # remove files and symbolic links
    if [ -f "$tfile" ]; then
      rm "$tfile" 1>/dev/null 2>&1 && printInfo " DELETED: $tfile"
    elif [ -L "$tfile" ]; then
      rm -f "$tfile" 1>/dev/null 2>&1 && printInfo " DELETED LINK: $tfile"
    fi
  done < "$pkgtrack"

  while IFS= read -r tdir; do # Remove empty dirs.
    rm -d "$tdir" 1>/dev/null 2>&1 && printWar " REMOVE DIR: $tdir"
  done < "$pkgtrack"

  # Remove track file in db
  rm "$pkgtrack" && printInfo " REMOVE TRACK: $pkgtrack"
}

# Lists installed packages
LIST() {
  for absolute_path in "${FAKE}/var/db/tinypkg"/*; do
    package_name=$(printf '%s' "$absolute_path" | sed -e "s|.*/||")
    printf '%s\n' "$package_name"
  done
}

# Help
USAGE() {
  printf '%b\n' "
  ${BLUE}tinypkg:${RESET} The fastest and small package manager

-h             : Display this help.
-c             : Create package.
-i             : Install package(s).
-l             : Lists all installed package(s).
--fakeroot DIR : Changes installation / from another directory. Used with -i
-r             : Remove package(s).

"
  exit 0
}
#=========================== MAIN
# Not have any arguments?
[ "$#" -eq '0' ] && USAGE

# TODO
# we can improve this parser in the POSIX way ;)
while [ -n "$1" ]; do # Main loop
case "$1" in
  -c) shift; NULL "$1"; CREATEPKG "$1"; break ;;
  --fakeroot)
    shift
    if [ ! -d "$1" ]; then
      printError "FAKEROOT: $1 don't exist. ABORTED"
    else
      FAKE="${1%/}" # cut / end, for not future problems.
      shift
    fi
    ;;
  -l) LIST && exit 0 ;;
  -i) shift; while [ -n "$1" ]; do INSTALL "$1"; shift; done ;;
  -r) shift; while [ -n "$1" ]; do REMOVE "$1"; shift; done ;;
  *) USAGE ;;
esac
done
